import IProjectItemData, {
  ProjectItemEditPreference,
  ProjectItemErrorStatus,
  ProjectItemStorageType,
} from "./IProjectItemData";
import Log from "./../core/Log";
import { ProjectItemType } from "./IProjectItemData";
import Project, {
  AUTOGENERATED_CONTENT_TOKEN,
  AUTOGENERATED_JS_SEPARATOR,
  AUTOGENERATED_WHOLEFILE_GENERAL_SEPARATOR,
  minecraftScriptModules,
} from "./Project";
import { EventDispatcher } from "ste-events";
import IFile from "../storage/IFile";
import IFolder from "../storage/IFolder";
import StorageUtilities from "../storage/StorageUtilities";
import IAddonManifest, { IAddonDependency, IAddonModule } from "../minecraft/IAddonManifest";
import IGitHubInfo from "./IGitHubInfo";
import EntityTypeDefinition from "../minecraft/EntityTypeDefinition";
import { ProjectEditPreference, ProjectScriptLanguage } from "./IProjectData";
import MCWorld from "../minecraft/MCWorld";
import ZipStorage from "../storage/ZipStorage";
import Utilities from "../core/Utilities";
import { StorageErrorStatus } from "../storage/IStorage";

export default class ProjectItem {
  private _data: IProjectItemData;
  private _project: Project;
  private _onPropertyChanged = new EventDispatcher<ProjectItem, string>();
  private _onFileRetrieved = new EventDispatcher<ProjectItem, IFile>();
  private _onFolderRetrieved = new EventDispatcher<ProjectItem, IFolder>();
  private _onLoaded = new EventDispatcher<ProjectItem, ProjectItem>();
  private _file: IFile | null;
  private _pendingLoadRequests: ((value: unknown) => void)[] = [];
  private _isLoading: boolean = false;
  private _folder: IFolder | null;
  private _isFileContentProcessed: boolean = false;
  private _items: ProjectItem[] | undefined;

  constructor(parent: Project, incomingData?: IProjectItemData) {
    this._project = parent;
    this._file = null;
    this._folder = null;
    this._isFileContentProcessed = false;
    this._handleMCWorldLoaded = this._handleMCWorldLoaded.bind(this);

    if (incomingData !== undefined && incomingData !== null) {
      this._data = incomingData;
    } else {
      this._data = {
        itemType: ProjectItemType.unknown,
        storagePath: null,
        storageType: ProjectItemStorageType.singleFile,
        tags: [],
        name: "",
      };
    }
  }

  public get project() {
    return this._project;
  }

  public get onPropertyChanged() {
    return this._onPropertyChanged.asEvent();
  }

  public get onLoaded() {
    return this._onLoaded.asEvent();
  }

  public get onFileRetrieved() {
    return this._onFileRetrieved.asEvent();
  }

  public get onFolderRetrieved() {
    return this._onFolderRetrieved.asEvent();
  }

  public get gitHubReference() {
    return this._data.gitHubReference;
  }

  public get isInFileContainer() {
    if (!this.storagePath) {
      return false;
    }

    return this.storagePath.indexOf("#") >= 0;
  }

  public get isFileContainerStorageItem() {
    return (
      this.itemType === ProjectItemType.zip ||
      this.itemType === ProjectItemType.MCWorld ||
      this.itemType === ProjectItemType.MCProject ||
      this.itemType === ProjectItemType.MCAddon ||
      this.itemType === ProjectItemType.MCPack ||
      this.itemType === ProjectItemType.MCTemplate
    );
  }

  public get isWorld() {
    return (
      this.itemType === ProjectItemType.MCProject ||
      this.itemType === ProjectItemType.MCWorld ||
      this.itemType === ProjectItemType.MCTemplate ||
      this.itemType === ProjectItemType.worldFolder
    );
  }

  static getGitHubSignature(info: IGitHubInfo) {
    let sig = info.owner + "|" + info.repoName + "|";

    if (info.branch !== undefined) {
      sig += info.branch;
    }

    if (info.folder !== undefined) {
      sig += "|" + info.folder;
    }

    return sig;
  }

  static gitHubReferencesEqual(refA: IGitHubInfo | undefined, refB: IGitHubInfo | undefined) {
    if (refA === refB) {
      return true;
    }

    if (refA === undefined && refB === undefined) {
      return true;
    }

    if (
      refA !== undefined &&
      refB !== undefined &&
      refA.owner === refB.owner &&
      refA.repoName === refB.repoName &&
      refA.folder === refB.folder &&
      refA.branch === refB.branch
    ) {
      return true;
    }

    return false;
  }

  public set gitHubReference(value: IGitHubInfo | undefined) {
    if (ProjectItem.gitHubReferencesEqual(this._data.gitHubReference, value)) {
      return;
    }

    this._data.gitHubReference = value;

    this._project.notifyProjectItemChanged(this);
  }

  static getDescriptionForType(type: ProjectItemType) {
    switch (type) {
      case ProjectItemType.js:
        return "JavaScript";
      case ProjectItemType.buildProcessedJs:
        return "Built JavaScript";
      case ProjectItemType.ts:
        return "TypeScript";
      case ProjectItemType.json:
        return "Generic json file";
      case ProjectItemType.behaviorPackManifestJson:
        return "Behavior pack manifest";
      case ProjectItemType.resourcePackManifestJson:
        return "Resource pack manifest";
      case ProjectItemType.testJs:
        return "Test JavaScript file";
      case ProjectItemType.entityTypeBaseJs:
        return "Entity type JavaScript file";
      case ProjectItemType.entityTypeBaseTs:
        return "Entity type TypeScript file";
      case ProjectItemType.entityTypeBehaviorJson:
        return "Entity type";
      case ProjectItemType.MCTemplate:
        return "Minecraft template";
      case ProjectItemType.MCWorld:
        return "Minecraft world";
      case ProjectItemType.MCProject:
        return "Minecraft project";
      case ProjectItemType.MCAddon:
        return "Minecraft addon";
      case ProjectItemType.MCPack:
        return "Minecraft pack";
      case ProjectItemType.zip:
        return "Minecraft zip";
      case ProjectItemType.worldFolder:
        return "Minecraft world (f)";
      case ProjectItemType.structure:
        return "Structure";
      case ProjectItemType.MCFunction:
        return "Function";
      case ProjectItemType.tickJson:
        return "Tick";
      case ProjectItemType.material:
        return "Material";
      case ProjectItemType.materialSetJson:
        return "Material Set";
      case ProjectItemType.geometry:
        return "Geometry";
      case ProjectItemType.fragment:
        return "Fragment";
      case ProjectItemType.vertex:
        return "Vertex";
      case ProjectItemType.cameraJson:
        return "Camera";
      case ProjectItemType.catalogIndexJs:
        return "Catalog index";
      case ProjectItemType.autoScriptJson:
        return "Auto-script";
      case ProjectItemType.worldTest:
        return "World test";
      case ProjectItemType.behaviorPackListJson:
        return "World behavior pack list";
      case ProjectItemType.resourcePackListJson:
        return "World resource pack list";
      case ProjectItemType.animationBehaviorJson:
        return "Behavior pack animation";
      case ProjectItemType.animationControllerBehaviorJson:
        return "Behavior pack animation controller";
      case ProjectItemType.blockTypeBehaviorJson:
        return "Block type";
      case ProjectItemType.blockMaterialsBehaviorJson:
        return "Block type materials";
      case ProjectItemType.itemTypeBehaviorJson:
        return "Item type";
      case ProjectItemType.lootTableBehaviorJson:
        return "Loot table";
      case ProjectItemType.biomeResourceJson:
        return "Biome resources";
      case ProjectItemType.blocksCatalogResourceJson:
        return "Block resource catalog";
      case ProjectItemType.soundsCatalogResourceJson:
        return "Sound catalog";
      case ProjectItemType.animationResourceJson:
        return "Animation";
      case ProjectItemType.animationControllerResourceJson:
        return "Animation controller";
      case ProjectItemType.entityTypeResourceJson:
        return "Entity type resources";
      case ProjectItemType.fogResourceJson:
        return "Fog";
      case ProjectItemType.modelJson:
        return "Model";
      case ProjectItemType.particleJson:
        return "Particle";
      case ProjectItemType.renderControllerJson:
        return "Render controller";
      case ProjectItemType.itemTextureJson:
        return "Texture";
      case ProjectItemType.uiJson:
        return "User interface";
      case ProjectItemType.languagesCatalogResourceJson:
        return "Language catalog";
      case ProjectItemType.biomeBehaviorJson:
        return "Biome";
      case ProjectItemType.dialogueBehaviorJson:
        return "Entity dialogue";
      case ProjectItemType.featureRuleBehaviorJson:
        return "World feature rule";
      case ProjectItemType.featureBehaviorJson:
        return "Feature";
      case ProjectItemType.functionEventJson:
        return "Function event";
      case ProjectItemType.recipeBehaviorJson:
        return "Recipe";
      case ProjectItemType.spawnRuleBehaviorJson:
        return "Spawn rule";
      case ProjectItemType.tradingBehaviorJson:
        return "Trading";
      case ProjectItemType.volumeBehaviorJson:
        return "Volume";
      case ProjectItemType.attachableResourceJson:
        return "Attachable";
      case ProjectItemType.itemTypeResourceJson:
        return "Item type resources";
      case ProjectItemType.materialsResourceJson:
        return "Materials";
      case ProjectItemType.musicDefinitionJson:
        return "Music";
      case ProjectItemType.soundDefinitionJson:
        return "Sound";
      case ProjectItemType.tsconfigJson:
        return "TypeScript config";
      case ProjectItemType.jsconfigJson:
        return "JavaScript config";
      case ProjectItemType.docfxJson:
        return "DocFX definition";
      case ProjectItemType.jsdocJson:
        return "JSDoc definition";
      case ProjectItemType.packageJson:
        return "NPM package definition";
      case ProjectItemType.packageLockJson:
        return "NPM package lock definition";
      case ProjectItemType.docInfoJson:
        return "Doc info json";
      case ProjectItemType.typesDefinitionJson:
        return "Types definition";
      case ProjectItemType.commandSetDefinitionJson:
        return "Command definition";
      case ProjectItemType.skinPackManifestJson:
        return "Skin pack manifest";
      case ProjectItemType.blockTypeBaseJs:
        return "Block type base javascript";
      case ProjectItemType.blockTypeBaseTs:
        return "Block type base typescript";
      case ProjectItemType.image:
        return "Image";
      case ProjectItemType.vsCodeLaunchJson:
        return "VS Code launch";
      case ProjectItemType.vsCodeTasksJson:
        return "VS Code tasks";
      case ProjectItemType.vsCodeSettingsJson:
        return "VS Code settings";
      case ProjectItemType.vsCodeExtensionsJson:
        return "VS Code extensions";
      case ProjectItemType.lang:
        return "Language translations";
      case ProjectItemType.worldTemplateManifestJson:
        return "World template manifest";
      case ProjectItemType.textureSetJson:
        return "Texture Sets";
      case ProjectItemType.lightingJson:
        return "Lighting";
      default:
        return "Unknown";
    }
  }
  get typeTitle() {
    return ProjectItem.getDescriptionForType(this._data.itemType);
  }

  getSchemaPath() {
    switch (this._data.itemType) {
      case ProjectItemType.behaviorPackManifestJson:
        return "general/manifest.json";
      case ProjectItemType.behaviorPackListJson:
        return "general/world_x_packs.json";
      case ProjectItemType.resourcePackListJson:
        return "general/world_x_packs.json";
      case ProjectItemType.animationControllerBehaviorJson:
        return "behavior/animation_controllers/animation_controller.json";
      case ProjectItemType.animationBehaviorJson:
        return "behavior/animations/animations.json";
      case ProjectItemType.blockTypeBehaviorJson:
        return "behavior/blocks/blocks.json";
      case ProjectItemType.blockMaterialsBehaviorJson:
        return "behavior/blocks/blocks.json";
      case ProjectItemType.itemTypeBehaviorJson:
        return "behavior/items/items.json";
      case ProjectItemType.lootTableBehaviorJson:
        return "behavior/loot_tables/loot_tables.json";
      case ProjectItemType.biomeBehaviorJson:
        return "behavior/blocks/blocks.json";
      case ProjectItemType.dialogueBehaviorJson:
        return "behavior/dialogue/dialogue.json";
      case ProjectItemType.blocksCatalogResourceJson:
        return "resource/blocks.json";
      case ProjectItemType.soundsCatalogResourceJson:
        return "resource/sounds.json";
      case ProjectItemType.animationResourceJson:
        return "resource/animations/actor_animation.json";
      case ProjectItemType.animationControllerResourceJson:
        return "resource/animation_controllers/animation_controller.json";
      case ProjectItemType.entityTypeResourceJson:
        return "resource/entity/entity.json";
      case ProjectItemType.fogResourceJson:
        return "resource/fog/fog.json";
      case ProjectItemType.modelJson:
        return "resource/models/entity/model_entity.json";
      case ProjectItemType.particleJson:
        return "resource/particles/particles.json";
      case ProjectItemType.renderControllerJson:
        return "resource/render_controllers/render_controllers.json";
      case ProjectItemType.itemTextureJson:
        return "resource/textures/item_texture.json";
      case ProjectItemType.languagesCatalogResourceJson:
        return "language/languages.json";
      case ProjectItemType.featureBehaviorJson:
        return "behavior/features/features.json";
      case ProjectItemType.featureRuleBehaviorJson:
        return "behavior/feature_rules/feature_rules.json";
      case ProjectItemType.functionEventJson:
        return "behavior/functions/tick.json";
      case ProjectItemType.recipeBehaviorJson:
        return "behavior/recipes/recipes.json";
      case ProjectItemType.spawnRuleBehaviorJson:
        return "behavior/spawn_rules/spawn_rules.json";
      case ProjectItemType.tradingBehaviorJson:
        return "behavior/trading/trading.json";
      case ProjectItemType.attachableResourceJson:
        return "resource/attachables/attachables.json";
      case ProjectItemType.itemTypeResourceJson:
        return "resource/items/items.json";
      case ProjectItemType.materialsResourceJson:
        return "resource/items/materials.json";
      case ProjectItemType.musicDefinitionJson:
        return "resource/sounds/music_definitions.json";
      case ProjectItemType.soundDefinitionJson:
        return "resource/sounds/sound_definitions.json";
      case ProjectItemType.blockTypeResourceJson:
        return "resource/blocks.json";

      //        uiJson = 36,

      default:
        return undefined;
    }
  }

  get errorStatus() {
    return this._data.errorStatus;
  }

  set errorStatus(newErrorStatus: ProjectItemErrorStatus | undefined) {
    this._data.errorStatus = newErrorStatus;
  }

  get errorMessage() {
    return this._data.errorMessage;
  }

  set errorMessage(newErrorMessage: string | undefined) {
    this._data.errorMessage = newErrorMessage;
  }

  get storagePath() {
    return this._data.storagePath;
  }

  set storagePath(newBasePath: string | undefined | null) {
    this._data.storagePath = newBasePath;
  }

  get effectiveEditPreference() {
    const ep = this.editPreference;

    if (ep === ProjectItemEditPreference.projectDefault) {
      return this._project.editPreference;
    } else if (ep === ProjectItemEditPreference.forceRaw) {
      return ProjectEditPreference.raw;
    } else {
      return ProjectEditPreference.summarized;
    }
  }

  get editPreference() {
    if (this._data.editPreference === undefined) {
      return ProjectItemEditPreference.projectDefault;
    }

    return this._data.editPreference;
  }

  set editPreference(newEditPreference: ProjectItemEditPreference) {
    this._data.editPreference = newEditPreference;
  }

  get storageType() {
    if (this._data.storageType === undefined) {
      return ProjectItemStorageType.singleFile;
    }

    return this._data.storageType;
  }

  set storageType(newStorageType: ProjectItemStorageType) {
    this._data.storageType = newStorageType;
  }

  get isAutogenerated() {
    return this._data.isAutogenerated;
  }

  get itemType() {
    return this._data.itemType;
  }

  get file() {
    return this._file;
  }

  get folder() {
    return this._folder;
  }

  set itemType(newItemType) {
    this._data.itemType = newItemType;

    this._onPropertyChanged.dispatch(this, "itemType");

    this._project.notifyProjectItemChanged(this);
  }

  get isLoaded() {
    if (this.storageType === ProjectItemStorageType.folder) {
      if (!this.folder) {
        return false;
      }

      if (!this.folder.isLoaded) {
        return false;
      }

      if (this.itemType === ProjectItemType.worldFolder) {
        if (!this.folder.manager || !(this.folder.manager instanceof MCWorld)) {
          return false;
        }

        const world = this.folder.manager as MCWorld;

        return world.isLoaded;
      }

      return true;
    } else if (this.storageType === ProjectItemStorageType.singleFile) {
      if (!this.file) {
        return false;
      }

      if (!this.file.isContentLoaded) {
        return false;
      }

      if (this.isWorld) {
        if (!this.file.manager || !(this.file.manager instanceof MCWorld)) {
          return false;
        }

        const world = this.file.manager as MCWorld;

        return world.isLoaded;
      }

      return this._isFileContentProcessed;
    }

    Log.unexpectedContentState();

    return false;
  }

  get tags() {
    return this._data.tags;
  }

  setFile(file: IFile) {
    if (file !== this._file) {
      this._file = file;
      this._isFileContentProcessed = false;
    }
  }

  get needsSave() {
    if (this._file === null && this.isAutogenerated && this.storageType === ProjectItemStorageType.singleFile) {
      return true;
    }

    if (this._file === null) {
      return false;
    }

    let val = this._file.needsSave;

    if (!val) {
      if (
        this.isFileContainerStorageItem &&
        this._file.fileContainerStorage &&
        this._file.fileContainerStorage instanceof ZipStorage
      ) {
        val = (this._file.fileContainerStorage as ZipStorage).isContentUpdated;
      }

      if (!val) {
        const tsFile = this.getTypeScriptTwin();

        if (tsFile !== undefined) {
          val = tsFile.needsSave;
        }

        const jsFile = this.getJavaScriptTwin();

        if (jsFile !== undefined) {
          val = jsFile.needsSave;
        }
      }
    }

    return val;
  }

  async rename(newFileBaseName: string) {
    await this.load();

    await this._project.ensureProjectFolder();

    if (this._project.projectFolder === undefined || this._project.projectFolder === null) {
      return;
    }

    if (this._file !== null) {
      await this._file.moveTo(this._file.parentFolder.storageRelativePath + newFileBaseName + "." + this._file.type);

      this._data.name = newFileBaseName + "." + this._file.type;

      this.storagePath = this._file.getFolderRelativePath(this._project.projectFolder);
      this.storageType = ProjectItemStorageType.singleFile;
    } else {
      this._data.name = newFileBaseName;
    }

    this._onPropertyChanged.dispatch(this, "name");

    this._project.notifyProjectItemChanged(this);
  }

  async deleteItem() {
    await this.load();

    if (this._file !== null) {
      this._file.deleteThisFile();
    }

    this._project.removeItem(this);
  }

  get imageUrl() {
    if (this.itemType === ProjectItemType.worldFolder) {
      if (this.folder) {
        if (this.folder.manager instanceof MCWorld) {
          const world = this.folder.manager as MCWorld;

          if (world.isLoaded) {
            return "data:image/jpg;base64, " + world.imageBase64;
          }
        }
      }
    } else if (this.isWorld) {
      if (this.file) {
        if (this.file.manager instanceof MCWorld) {
          const world = this.file.manager as MCWorld;

          if (world.isLoaded) {
            return "data:image/jpg;base64, " + world.imageBase64;
          }
        }
      }
    }
    return undefined;
  }

  get name() {
    if (this.itemType === ProjectItemType.worldFolder) {
      if (this.folder) {
        if (this.folder.manager instanceof MCWorld) {
          const world = this.folder.manager as MCWorld;

          if (world.isLoaded) {
            return world.name;
          }
        }
      }
    } else if (this.itemType === ProjectItemType.MCWorld || this.itemType === ProjectItemType.MCTemplate) {
      if (this.file) {
        if (this.file.manager instanceof MCWorld) {
          const world = this.file.manager as MCWorld;

          if (world.isLoaded) {
            return world.name;
          }
        }
      }
    }

    // for certain types of project items, the name of the file is critical
    if (
      this.storagePath &&
      (this.itemType === ProjectItemType.js ||
        this.itemType === ProjectItemType.ts ||
        this.itemType === ProjectItemType.testJs ||
        this.itemType === ProjectItemType.structure)
    ) {
      return StorageUtilities.getLeafName(this.storagePath);
    }

    if (this._data.name !== undefined) {
      return this._data.name;
    }

    if (this.storagePath) {
      return StorageUtilities.getLeafName(this.storagePath);
    }

    return "untitled";
  }

  async ensureFolderStorage() {
    if (this.storageType === ProjectItemStorageType.folder) {
      if (
        this._folder === null &&
        this.storagePath !== null &&
        this.storagePath !== undefined &&
        this.storagePath.startsWith("/") &&
        this._project.projectFolder !== null &&
        this._project.projectFolder !== undefined
      ) {
        const prefixPaths = this.storagePath.split("#");

        if (prefixPaths.length > 1) {
          let folderToLoadFrom: IFolder | undefined = this._project.projectFolder;

          for (let i = 0; i < prefixPaths.length - 1; i++) {
            if (folderToLoadFrom) {
              const zipFile: IFile = await folderToLoadFrom.ensureFileFromRelativePath(prefixPaths[i]);

              await zipFile.loadContent();

              if (zipFile.content && zipFile.content instanceof Uint8Array) {
                if (!zipFile.fileContainerStorage) {
                  const zipStorage = new ZipStorage();

                  zipStorage.storagePath = zipFile.storageRelativePath + "#";

                  await zipStorage.loadFromUint8Array(zipFile.content, zipFile.name);

                  zipFile.fileContainerStorage = zipStorage;
                }

                folderToLoadFrom = zipFile.fileContainerStorage.rootFolder;
              } else {
                folderToLoadFrom = undefined;
              }
            }
          }

          if (folderToLoadFrom) {
            this._folder = await folderToLoadFrom.ensureFolderFromRelativePath(prefixPaths[prefixPaths.length - 1]);
          } else {
            // Log.debugAlert("Unable to parse a containerized file path of '" + this.storagePath + "'");
            return null;
          }
        } else {
          this._folder = await this._project.projectFolder.ensureFolderFromRelativePath(this.storagePath);
        }

        await this._folder.load(false);

        this._onFolderRetrieved.dispatch(this, this._folder);

        if (this.itemType === ProjectItemType.worldFolder) {
          const mcworld = await MCWorld.ensureMCWorldOnFolder(this._folder, this._project, this._handleMCWorldLoaded);

          if (mcworld) {
            this.errorMessage = mcworld.storageErrorMessage;

            if (mcworld.storageErrorStatus === StorageErrorStatus.unprocessable) {
              this.errorStatus = ProjectItemErrorStatus.unprocessable;
            } else {
              this.errorStatus = ProjectItemErrorStatus.none;
            }
          }
        } else {
          this._fireLoadedEvent();
        }
      }

      return this._folder;
    }

    return undefined;
  }

  _handleMCWorldLoaded(world: MCWorld, worldA: MCWorld) {
    this._fireLoadedEvent();
  }

  _fireLoadedEvent() {
    if (this._onLoaded && this.isLoaded) {
      this._onLoaded.dispatch(this, this);
    }
  }

  async getManager() {
    await this.load();

    if (this.storageType === ProjectItemStorageType.singleFile && this._file) {
      return this._file.manager;
    }

    if (this.storageType === ProjectItemStorageType.folder && this._folder) {
      return this._folder.manager;
    }

    return undefined;
  }

  async ensureFileStorage() {
    if (
      this.storageType === ProjectItemStorageType.singleFile &&
      this._file === null &&
      this.storagePath !== null &&
      this.storagePath !== undefined &&
      this.storagePath.startsWith("/") &&
      this._project.projectFolder !== null &&
      this._project.projectFolder !== undefined
    ) {
      const prefixPaths = this.storagePath.split("#");

      if (prefixPaths.length > 1) {
        let folderToLoadFrom: IFolder | undefined = this._project.projectFolder;

        for (let i = 0; i < prefixPaths.length - 1; i++) {
          if (folderToLoadFrom) {
            const zipFile: IFile = await folderToLoadFrom.ensureFileFromRelativePath(prefixPaths[i]);

            await zipFile.loadContent();

            if (zipFile.content && zipFile.content instanceof Uint8Array) {
              if (!zipFile.fileContainerStorage) {
                const zipStorage = new ZipStorage();

                zipStorage.storagePath = zipFile.storageRelativePath + "#";

                await zipStorage.loadFromUint8Array(zipFile.content, zipFile.name);

                zipFile.fileContainerStorage = zipStorage;
              }

              folderToLoadFrom = zipFile.fileContainerStorage.rootFolder;
            } else {
              folderToLoadFrom = undefined;
            }
          }
        }

        if (folderToLoadFrom) {
          this._file = await folderToLoadFrom.ensureFileFromRelativePath(prefixPaths[prefixPaths.length - 1]);
          this._isFileContentProcessed = false;
        } else {
          Log.debugAlert("Unable to parse a containerized file path of '" + this.storagePath + "'");
          return null;
        }
      } else {
        this._file = await this._project.projectFolder.ensureFileFromRelativePath(this.storagePath);
        this._isFileContentProcessed = false;
      }
    }

    if (!this._isFileContentProcessed && this._file) {
      if (this._data.isAutogenerated === true) {
        await this.updateAutogenerated();
      } else {
        await this._file.loadContent();
      }

      await this.updateAutogeneratedSideFiles();

      this._isFileContentProcessed = true;

      this._onFileRetrieved.dispatch(this, this._file);

      if (this.itemType === ProjectItemType.MCWorld || this.itemType === ProjectItemType.MCTemplate) {
        const mcworld = await MCWorld.ensureMCWorldOnFile(this._file, this._project, this._handleMCWorldLoaded);

        if (mcworld) {
          this.errorMessage = mcworld.storageErrorMessage;

          if (mcworld.storageErrorStatus === StorageErrorStatus.unprocessable) {
            this.errorStatus = ProjectItemErrorStatus.unprocessable;
          } else {
            this.errorStatus = ProjectItemErrorStatus.none;
          }
        }
      } else if (this.itemType === ProjectItemType.entityTypeBehaviorJson) {
        await EntityTypeDefinition.ensureEntityTypeOnFile(this._file);

        this._fireLoadedEvent();
      } else {
        this._fireLoadedEvent();
      }
    }
    return this._file;
  }

  async getJsonObject(): Promise<object | undefined> {
    let strContent = await this.getStringContent();

    if (!strContent) {
      return undefined;
    }

    let obj = undefined;

    try {
      strContent = Utilities.fixJsonContent(strContent);
      obj = JSON.parse(strContent);
    } catch (e) {
      Log.debug("Could not parse content '" + strContent + "': " + e, this.project.name);
    }

    return obj;
  }

  async getStringContent(): Promise<string | undefined> {
    await this.load();

    if (!this._file) {
      return undefined;
    }

    await this._file.loadContent();

    if (this._file.content instanceof Uint8Array || this._file.content === null) {
      return undefined;
    }

    return this._file.content;
  }

  async load() {
    if (this.isLoaded) {
      return true;
    }

    if (this._isLoading) {
      const pendingLoad = this._pendingLoadRequests;

      const prom = (resolve: (value: unknown) => void, reject: (reason?: any) => void) => {
        pendingLoad.push(resolve);
      };

      await new Promise(prom);

      return true;
    } else {
      this._isLoading = true;

      if (this.storageType === ProjectItemStorageType.folder) {
        await this.ensureFolderStorage();
      } else if (this.storageType === ProjectItemStorageType.singleFile) {
        await this.ensureFileStorage();
      }

      this._isLoading = false;

      const pendingLoad = this._pendingLoadRequests;
      this._pendingLoadRequests = [];

      for (const prom of pendingLoad) {
        prom(undefined);
      }

      return true;
    }
  }

  async updateAutogenerated() {
    if (!this._isLoading) {
      await this.load();
    }

    if (this._file == null || !this._data.isAutogenerated) {
      return;
    }

    if (this.itemType === ProjectItemType.catalogIndexJs) {
      await this._file.loadContent();

      this._updateAutogeneratedContent(await this.getCatalogJsContent());
    } else if (this.itemType === ProjectItemType.behaviorPackManifestJson) {
      this._file.setContent(await this.getBehaviorPackManifestJsonContent());
    } else if (this.itemType === ProjectItemType.entityTypeBaseJs) {
      const content = await this.getGeneratedTypeJavaScript();

      if (content.javaScript !== undefined) {
        this._file.setContent(content.javaScript);
      }

      if (
        this._project.preferredScriptLanguage === ProjectScriptLanguage.typeScript &&
        content.typeScript !== undefined
      ) {
        const file = this._file.parentFolder.ensureFile(StorageUtilities.getBaseFromName(this._file.name) + ".ts");

        file.setContent(content.typeScript);
      }
    } else if (this.itemType === ProjectItemType.entityTypeBaseTs) {
      const content = await this.getGeneratedTypeJavaScript();

      if (content.typeScript !== undefined) {
        this._file.setContent(content.typeScript);
      }
    }
  }

  async updateAutogeneratedSideFiles() {
    if (!this._file || !this._project || !this._project.defaultBehaviorPackFolder) {
      return;
    }
  }

  _updateAutogeneratedContent(newContent: string) {
    if (this._file == null || this._file.content instanceof Uint8Array) {
      Log.unexpectedContentState();
      return;
    }

    if (this._file.content === undefined || this._file.content === null || this._file.content.trim() === "") {
      this._file.setContent(newContent);
      return;
    }

    let updatedContent = this._file.content;

    const autogenToken = updatedContent.indexOf(AUTOGENERATED_CONTENT_TOKEN);

    if (autogenToken >= 0) {
      let previous = updatedContent.lastIndexOf("\r", autogenToken);

      if (previous < 0) {
        previous = updatedContent.lastIndexOf("\n", autogenToken);

        if (previous < 0) {
          previous = 0;
        }
      }

      const previousComment = updatedContent.lastIndexOf("//", autogenToken);

      // we expect \r\n//, but if for some reason the comment has moved, let's only strip from the comment forward.
      if (previousComment > previous + 2) {
        previous = previousComment;
      }

      if (previous >= 0) {
        updatedContent = updatedContent.substring(0, previous);
      }
    }

    updatedContent += newContent;

    this._file.setContent(updatedContent);
  }

  async prepareToSave() {
    await this.load();

    await this.updateAutogenerated();
    await this.updateAutogeneratedSideFiles();

    if (
      !this.isInFileContainer &&
      this.isFileContainerStorageItem &&
      this.file &&
      this.file.fileContainerStorage &&
      this.file.fileContainerStorage instanceof ZipStorage
    ) {
      const zs = this.file.fileContainerStorage as ZipStorage;

      if (zs.isContentUpdated && (zs.errorStatus === undefined || zs.errorStatus === StorageErrorStatus.none)) {
        const op = await this._project.carto.notifyOperationStarted(
          "Zipping file '" + this.file.storageRelativePath + "'..."
        );
        const bytes = await zs.generateUint8ArrayAsync();
        await this._project.carto.notifyOperationEnded(
          op,
          "Done zipping file '" + this.file.storageRelativePath + "'."
        );

        this.file.setContent(bytes);
      }
    }
  }

  getTypeScriptTwin() {
    if (!this._file) {
      return undefined;
    }

    // consider saving a JS file's TS twin, if it exists.
    const extension = StorageUtilities.getTypeFromName(this._file.name);

    if (extension === "js") {
      const tsTwinName = StorageUtilities.canonicalizeName(StorageUtilities.getBaseFromName(this._file.name) + ".ts");

      return this._file.parentFolder.files[tsTwinName];
    }

    return undefined;
  }

  getJavaScriptTwin() {
    if (!this._file) {
      return undefined;
    }

    // consider saving a JS file's TS twin, if it exists.
    const extension = StorageUtilities.getTypeFromName(this._file.name);

    if (extension === "json") {
      const jsTwinName = StorageUtilities.canonicalizeName(StorageUtilities.getBaseFromName(this._file.name) + ".js");

      return this._file.parentFolder.files[jsTwinName];
    }

    return undefined;
  }

  getFunctionTwin() {
    if (!this._file) {
      return undefined;
    }

    // consider saving a JS file's TS twin, if it exists.
    const extension = StorageUtilities.getTypeFromName(this._file.name);

    if (extension === "json") {
      const functionTwinName = StorageUtilities.canonicalizeName(
        StorageUtilities.getBaseFromName(this._file.name) + ".mcfunction"
      );

      let functionFolder = this._file.parentFolder;

      if (functionFolder.name === "scripts" && functionFolder.parentFolder) {
        functionFolder = functionFolder.parentFolder.ensureFolder("functions");
      }

      return functionFolder.files[functionTwinName];
    }

    return undefined;
  }

  async saveContent() {
    if (this._file) {
      await this._file.saveContent();

      const tsFile = this.getTypeScriptTwin();

      if (tsFile !== undefined && tsFile.needsSave) {
        await tsFile.saveContent();
      }

      // these next two are associated with autoscripting
      const jsFile = this.getJavaScriptTwin();

      if (jsFile !== undefined && jsFile.needsSave) {
        await jsFile.saveContent();
      }

      const functionFile = this.getFunctionTwin();

      if (functionFile !== undefined && functionFile.needsSave) {
        await functionFile.saveContent();
      }
    }
  }

  hasTag(name: string) {
    return this.tags.includes(name);
  }

  ensureTag(name: string) {
    if (this.hasTag(name)) {
      return;
    }

    this.tags.push(name);
  }

  async getGeneratedTypeJavaScript() {
    if (this.storagePath === null || this.storagePath === undefined) {
      return { javaScript: "", typeScript: undefined };
    }

    let typeName = StorageUtilities.getBaseFromName(StorageUtilities.getLeafName(this.storagePath));

    if (typeName.endsWith(".base")) {
      typeName = typeName.substring(0, typeName.length - 5);
    }

    for (let i = 0; i < this._project.items.length; i++) {
      const item = this._project.items[i];

      if (
        item.itemType === ProjectItemType.entityTypeBehaviorJson &&
        item.storagePath !== null &&
        item.storagePath !== undefined
      ) {
        const jsonName = StorageUtilities.getBaseFromName(StorageUtilities.getLeafName(item.storagePath));

        if (jsonName === typeName) {
          const jsonFile = await item.ensureFileStorage();

          if (jsonFile !== undefined && jsonFile !== null) {
            if (jsonFile.manager === undefined) {
              await EntityTypeDefinition.ensureEntityTypeOnFile(jsonFile);
            }

            if (jsonFile.manager) {
              const et = jsonFile.manager as EntityTypeDefinition;

              const js = et.getScript(false);
              let ts = undefined;

              if (this._project.preferredScriptLanguage === ProjectScriptLanguage.typeScript) {
                ts = et.getScript(true);
              }

              return { javaScript: js, typeScript: ts };
            }
          }
        }
      }
    }

    return { javaScript: "", typeScript: undefined };
  }

  async getBehaviorPackManifestJsonContent() {
    let versionMajor = 0;
    let versionMinor = 0;
    let versionPatch = 1;

    if (this._project.versionMajor !== undefined) {
      versionMajor = this._project.versionMajor;
    }

    if (this._project.versionMinor !== undefined) {
      versionMinor = this._project.versionMinor;
    }

    if (this._project.versionPatch !== undefined) {
      versionPatch = this._project.versionPatch;
    }

    const modulesList: IAddonModule[] = [];
    const dependenciesList: IAddonDependency[] = [];
    let scriptFile = undefined;
    let pi = this._project.getFirstItemByType(ProjectItemType.catalogIndexJs);

    if (pi !== undefined) {
      scriptFile = pi.file;
    }

    const behaviorPackRootFolder = await this._project.ensureDefaultBehaviorPackFolder();

    if (scriptFile === undefined) {
      pi = this._project.getFirstItemByType(ProjectItemType.js);
      if (pi !== undefined) {
        scriptFile = pi.file;
      }

      if (scriptFile === undefined) {
        pi = this._project.getFirstItemByType(ProjectItemType.testJs);

        if (pi !== undefined) {
          scriptFile = pi.file;
        }
      }
    }

    const scriptState = this._project.getScriptState();

    if (scriptState.hasScript && scriptFile !== null && scriptFile !== undefined && behaviorPackRootFolder !== null) {
      let path = scriptFile.getFolderRelativePath(behaviorPackRootFolder);

      if (path !== undefined) {
        if (path.startsWith("/")) {
          path = path.substring(1, path.length);
        }

        modulesList.push({
          description: this._project.title + " script",
          language: "javascript",
          type: "script",
          uuid: this._project.defaultScriptModuleUniqueId,
          version: [versionMajor, versionMinor, versionPatch],
          entry: path,
        });

        for (let i = 0; i < minecraftScriptModules.length; i++) {
          const mod = minecraftScriptModules[i];

          if (scriptState.hasModule[mod.id]) {
            dependenciesList.push({
              uuid: mod.uuid,
              module_name: mod.module_name,
              version: mod.preferredVersion,
            });
          }
        }
      }
    }

    const manifest: IAddonManifest = {
      format_version: 2,
      __comment__: AUTOGENERATED_WHOLEFILE_GENERAL_SEPARATOR,
      header: {
        description: this._project.description,
        name: this._project.title,
        uuid: this._project.defaultBehaviorPackUniqueId,
        version: [versionMajor, versionMinor, versionPatch],
        min_engine_version: [1, 20, 10],
      },
      modules: modulesList,
      dependencies: dependenciesList,
    };

    return JSON.stringify(manifest, null, 2);
  }

  async getCatalogJsContent() {
    const content: string[] = [];

    const behaviorPackRootFolder = await this._project.ensureDefaultBehaviorPackFolder();

    for (let i = 0; i < this._project.items.length; i++) {
      const projectItem = this._project.items[i];

      if (projectItem.itemType === ProjectItemType.worldTest) {
        const file = await projectItem.ensureFileStorage();

        if (file) {
          const newFileName = StorageUtilities.getBaseFromName(file.name) + ".gen.js";

          content.push('import "scripts/' + newFileName + '";');
        }
      } else if (
        projectItem.itemType === ProjectItemType.js ||
        projectItem.itemType === ProjectItemType.buildProcessedJs ||
        projectItem.itemType === ProjectItemType.entityTypeBaseJs ||
        projectItem.itemType === ProjectItemType.testJs
      ) {
        const file = await projectItem.ensureFileStorage();

        if (file) {
          let filePath = file.getFolderRelativePath(behaviorPackRootFolder);

          if (!file.isContentLoaded) {
            await file.loadContent(false);
          }

          if ((file.content !== null || filePath !== null) && filePath !== undefined) {
            if (filePath.startsWith("/scripts/")) {
              filePath = filePath.substring(9, filePath.length);
            }

            if (filePath.startsWith("/")) {
              filePath = filePath.substring(1, filePath.length);
            }

            content.push('import "' + filePath + '";');
          }
        }
      }
    }

    return AUTOGENERATED_JS_SEPARATOR + "\r\n\r\n" + content.join("\r\n");
  }
}
