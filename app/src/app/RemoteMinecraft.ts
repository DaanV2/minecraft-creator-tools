import Carto, { CartoMinecraftErrorStatus, CartoMinecraftState } from "./Carto";
import { CartoServerAuthenticationResult, CartoServerStatus, DedicatedServerStatus } from "./CartoAuthentication";
import IMinecraft, { IMinecraftMessage, IPrepareAndStartResult, PrepareAndStartResultType } from "./IMinecraft";
import axios, { AxiosResponse } from "axios";
import { EventDispatcher } from "ste-events";
import Project from "./Project";
import MinecraftPush from "./MinecraftPush";
import ZipStorage from "../storage/ZipStorage";
import StorageUtilities from "../storage/StorageUtilities";
import Log from "../core/Log";
import GameStateManager from "../minecraft/GameStateManager";
import ProjectTools from "./ProjectTools";
import IFolder from "../storage/IFolder";
import MinecraftUtilities from "../minecraft/MinecraftUtilities";

export default class RemoteMinecraft implements IMinecraft {
  private _carto: Carto;
  public state: CartoMinecraftState;
  private _project: Project | undefined;
  private _lastFullPush: ZipStorage | undefined;
  private _onStateChanged = new EventDispatcher<IMinecraft, CartoMinecraftState>();
  private _gameStateManager: GameStateManager;

  private _nextPollInterval = 500;
  private _pollIntervalCount = 0;

  errorStatus?: CartoMinecraftErrorStatus;
  errorMessage?: string;

  worldFolder: IFolder | undefined;
  projectFolder: IFolder | undefined;

  private messagesReceived: { [received: number]: IMinecraftMessage } = {};

  private _onWorldStorageReady = new EventDispatcher<IMinecraft, IFolder>();
  private _onProjectStorageReady = new EventDispatcher<IMinecraft, IFolder>();
  private _onMessage = new EventDispatcher<IMinecraft, IMinecraftMessage>();

  public get onWorldFolderReady() {
    return this._onWorldStorageReady.asEvent();
  }

  public get onProjectFolderReady() {
    return this._onProjectStorageReady.asEvent();
  }

  public get onMessage() {
    return this._onMessage.asEvent();
  }

  get canDeployFiles() {
    return true;
  }

  get activeProject() {
    return this._project;
  }

  set activeProject(newProject: Project | undefined) {
    this._project = newProject;
  }

  public get gameStateManager() {
    return this._gameStateManager;
  }

  public get onStateChanged() {
    return this._onStateChanged.asEvent();
  }

  public get onRefreshed() {
    return this._onStateChanged.asEvent();
  }

  canPrepare() {
    return true;
  }

  constructor(carto: Carto) {
    this._carto = carto;
    this.state = CartoMinecraftState.none;
    this._gameStateManager = new GameStateManager(this._carto);

    this.doHeartbeat = this.doHeartbeat.bind(this);
  }

  async updateStatus() {
    return this.state;
  }

  setState(newState: CartoMinecraftState) {
    if (this.state === newState) {
      return;
    }

    this.state = newState;
    this._onStateChanged.dispatch(this, this.state);
  }

  processExternalMessage(command: string, data: string): void {
    switch (command.toLowerCase()) {
      case "wsevent":
        try {
          const eventObj = JSON.parse(data);
          this._gameStateManager.handleEvent(eventObj);
        } catch (e) {}
        break;
    }
  }

  async prepare(force?: boolean) {}

  async prepareAndStart(push: MinecraftPush): Promise<IPrepareAndStartResult> {
    if (!push.project || !this._carto.remoteServerAuthToken) {
      Log.throwUnexpectedUndefined("PAS");
      return {
        type: PrepareAndStartResultType.error,
      };
    }

    this.setState(CartoMinecraftState.preparing);

    await push.project.updateAutogeneratedItems();

    const zipStorage = new ZipStorage();

    //await StorageUtilities.syncFolderTo(carto.deploymentStorage.rootFolder, zipStorage.rootFolder, true, true, false);

    const zipBehaviorPackFolder = await zipStorage.rootFolder.ensureFolder("development_behavior_packs");

    await ProjectTools.deployToBehaviorPackFolder(push.project, zipBehaviorPackFolder);

    await zipStorage.rootFolder.saveAll();

    // consider doing a diff from the last push.
    if (this._lastFullPush) {
      const differenceSet = await StorageUtilities.getDifferences(
        this._lastFullPush.rootFolder,
        zipStorage.rootFolder,
        true
      );

      this._lastFullPush = zipStorage;

      // we don't have to do anything here. (may need a force flag here at some point)
      if (differenceSet.fileDifferences.length === 0 && differenceSet.folderDifferences.length === 0) {
        Log.message("No changes detected in this update. No push is being made.");
        return {
          type: PrepareAndStartResultType.error,
        };
      }

      if (!differenceSet.getHasDeletions()) {
        const diffUpdate = new ZipStorage();

        await differenceSet.copyFileUpdatesAndAdds(diffUpdate);
        await diffUpdate.rootFolder.saveAll();

        const diffBinary = await diffUpdate.generateBlobAsync();

        this._carto.notifyStatusUpdate("Uploading changed files to " + this._carto.fullRemoteServerUrl);

        const isReloadable = MinecraftUtilities.isReloadableSetOfChanges(differenceSet);

        await axios({
          method: "patch",
          url: this.getBaseApiUrl() + "upload/", //API url
          headers: {
            Authorization: "Bearer mctauth=" + this._carto.remoteServerAuthToken,
            "Content-Type": "application/zip",
            "mcttools-reloadable": isReloadable,
          },
          data: diffBinary, // Buffer
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
        });

        this._carto.notifyStatusUpdate("Upload complete");
        return {
          type: PrepareAndStartResultType.started,
        };
      }
    }

    this._carto.notifyStatusUpdate("Files created in zip. Packaging");

    const zipBinary = await zipStorage.generateBlobAsync();

    this._lastFullPush = zipStorage;

    this._carto.notifyStatusUpdate("Uploading to " + this._carto.fullRemoteServerUrl);

    await axios({
      method: "post",
      url: this.getBaseApiUrl() + "upload/", //API url
      headers: {
        Authorization: "Bearer mctauth=" + this._carto.remoteServerAuthToken,
        "Content-Type": "application/zip",
      },
      data: zipBinary, // Buffer
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
    });

    this.setState(CartoMinecraftState.prepared);

    this._carto.notifyStatusUpdate("Upload complete");

    return {
      type: PrepareAndStartResultType.started,
    };
  }

  async runCommand(command: string) {
    if (!this._carto.remoteServerAuthToken) {
      Log.throwUnexpectedUndefined("RC");
      return;
    }

    this.resetInterval();

    const result = await axios({
      method: "post",
      url: this.getBaseApiUrl() + "command/", //API url
      headers: {
        Authorization: "Bearer mctauth=" + this._carto.remoteServerAuthToken,
      },
      data: command,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
    });

    return result.data as string;
  }

  getBaseApiUrl(): string {
    if (!this._carto.fullRemoteServerUrl) {
      Log.throwUnexpectedUndefined("GBAU");
      return "";
    }

    let port = this._carto.remoteServerPort;

    if (!port) {
      port = 0;
    }

    return StorageUtilities.ensureEndsWithDelimiter(this._carto.fullRemoteServerUrl) + "api/" + port + "/";
  }

  async initSession(slot: number) {}

  async deploy() {}

  async stop() {}

  processServerStatus(newStatus: CartoServerStatus) {
    let wasActive = false;
    if (newStatus.status) {
      switch (newStatus.status) {
        case DedicatedServerStatus.deploying:
          if (this.state !== CartoMinecraftState.preparing) {
            this.setState(CartoMinecraftState.preparing);
            wasActive = true;
          }
          break;
        case DedicatedServerStatus.launching:
          if (this.state !== CartoMinecraftState.starting) {
            this.setState(CartoMinecraftState.starting);
            wasActive = true;
          }
          break;
        case DedicatedServerStatus.starting:
          if (this.state !== CartoMinecraftState.starting) {
            this.setState(CartoMinecraftState.starting);
            wasActive = true;
          }
          break;
        case DedicatedServerStatus.started:
          if (this.state !== CartoMinecraftState.started) {
            this.setState(CartoMinecraftState.started);

            if (!this._carto.successfullyConnectedToRemoteMinecraft) {
              this._carto.successfullyConnectedToRemoteMinecraft = true;
              this._carto.save();
            }

            wasActive = true;
          }
          break;
        case DedicatedServerStatus.stopped:
          if (this.state !== CartoMinecraftState.stopped) {
            this.setState(CartoMinecraftState.stopped);
            wasActive = true;
          }
          break;
      }
    }

    if (newStatus.recentMessages) {
      for (const recentMessage of newStatus.recentMessages) {
        if (!this.messagesReceived[recentMessage.received]) {
          this.messagesReceived[recentMessage.received] = recentMessage;

          this._carto.notifyStatusUpdate(recentMessage.message);

          this._onMessage.dispatch(this, recentMessage);
        }
      }
    }

    return wasActive;
  }

  resetInterval() {
    this._nextPollInterval = 100;
    this._pollIntervalCount = 0;
  }

  async doHeartbeat() {
    let wasActive = false;

    try {
      const result = await axios({
        method: "get",
        url: this.getBaseApiUrl() + "status/", //API url
        headers: {
          Authorization: "Bearer mctauth=" + this._carto.remoteServerAuthToken,
        },
      });

      const obj = result.data as CartoServerStatus;

      if (obj) {
        wasActive = this.processServerStatus(obj);
      }
    } catch (e) {
      this.errorMessage = "Disconnected from server";
      this.setState(CartoMinecraftState.disconnected);
      return;
    }

    if (this._nextPollInterval >= 0) {
      if (wasActive) {
        this._nextPollInterval = 100;
        this._pollIntervalCount = 0;
      } else {
        this._pollIntervalCount++;

        // back off our polling if nothing interesting is happening
        if (this._pollIntervalCount === 50 && this._nextPollInterval < 500) {
          this._nextPollInterval = 500;
          this._pollIntervalCount = 0;
        } else if (this._pollIntervalCount === 50 && this._nextPollInterval === 500) {
          this._nextPollInterval = 5000;
          this._pollIntervalCount = 0;
        }
      }

      // @ts-ignore
      window.setTimeout(this.doHeartbeat, this._nextPollInterval);
    }
  }

  async initialize() {
    const url = this._carto.fullRemoteServerUrl;
    this._nextPollInterval = -1;

    if (
      this.state === CartoMinecraftState.initialized ||
      this.state === CartoMinecraftState.preparing ||
      this.state === CartoMinecraftState.prepared ||
      this.state === CartoMinecraftState.starting ||
      this.state === CartoMinecraftState.started
    ) {
      return;
    }

    this.setState(CartoMinecraftState.initialized);

    if (!this._carto || !url || !this._carto.remoteServerPasscode) {
      this.errorMessage = "Not fully configured.";
      this.errorStatus = CartoMinecraftErrorStatus.configuration;
      return;
    }

    let authReq: AxiosResponse | undefined = undefined;

    try {
      authReq = await axios.post(url + "api/auth/", "passcode=" + this._carto.remoteServerPasscode);

      if (authReq === undefined) {
        this.errorMessage = "Could not connect to server.";
        this.errorStatus = CartoMinecraftErrorStatus.loginFailed;
        this.setState(CartoMinecraftState.error);
        return;
      }

      if (authReq.status !== 200) {
        this.errorMessage = "Login failed.";
        this.errorStatus = CartoMinecraftErrorStatus.loginFailed;
        this.setState(CartoMinecraftState.error);
        return;
      }

      let result: CartoServerAuthenticationResult | undefined = undefined;

      if (typeof authReq.data === "string") {
        result = JSON.parse(authReq.data);
      } else if (typeof authReq.data === "object") {
        result = authReq.data;
      }

      if (result === undefined) {
        this.errorMessage = "Unexpected server error.";
        this.errorStatus = CartoMinecraftErrorStatus.serverError;
        this.setState(CartoMinecraftState.error);

        return;
      }

      this.setState(CartoMinecraftState.initialized);

      this._carto.remoteServerAuthToken = result.token + "|" + result.iv;
      this._carto.remoteServerAccessLevel = result.permissionLevel;

      const desiredPort = this._carto.remoteServerPort;

      if (
        desiredPort !== undefined &&
        desiredPort >= 0 &&
        desiredPort <= 3 &&
        result.serverStatus.length > desiredPort
      ) {
        const status = result.serverStatus[desiredPort];
        this.processServerStatus(status);
      }

      await this._carto.save();
      this._nextPollInterval = 500;

      // @ts-ignore
      window.setTimeout(this.doHeartbeat, this._nextPollInterval);
    } catch (e: any) {
      this.errorMessage = e.toString();

      if (this.errorMessage && this.errorMessage.indexOf("401") >= 0) {
        this.errorStatus = CartoMinecraftErrorStatus.loginFailed;
        this.setState(CartoMinecraftState.error);
      } else {
        this.errorStatus = CartoMinecraftErrorStatus.serverUnavailable;
        this.setState(CartoMinecraftState.error);
      }
    }
  }
}
